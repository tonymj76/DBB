// Code generated by Prisma CLI (https://github.com/prisma/prisma). DO NOT EDIT.

package prisma

import (
	"context"
	"errors"

	"os"

	"github.com/prisma/prisma-client-lib-go"

	"github.com/machinebox/graphql"
)

var ErrNoResult = errors.New("query returned no result")

func Str(v string) *string { return &v }
func Int32(v int32) *int32 { return &v }
func Bool(v bool) *bool    { return &v }

type BatchPayloadExec struct {
	exec *prisma.BatchPayloadExec
}

func (exec *BatchPayloadExec) Exec(ctx context.Context) (BatchPayload, error) {
	bp, err := exec.exec.Exec(ctx)
	return BatchPayload(bp), err
}

type BatchPayload struct {
	Count int64 `json:"count"`
}

type Aggregate struct {
	Count int64 `json:"count"`
}

type Client struct {
	Client *prisma.Client
}

type Options struct {
	Endpoint string
	Secret   string
}

func New(options *Options, opts ...graphql.ClientOption) *Client {
	endpoint := DefaultEndpoint
	secret := Secret
	if options != nil {
		endpoint = options.Endpoint
		secret = options.Secret
	}
	return &Client{
		Client: prisma.New(endpoint, secret, opts...),
	}
}

func (client *Client) GraphQL(ctx context.Context, query string, variables map[string]interface{}) (map[string]interface{}, error) {
	return client.Client.GraphQL(ctx, query, variables)
}

var DefaultEndpoint = "http://localhost:4467"
var Secret = os.Getenv("DBB_SECRET")

func (client *Client) Address(params AddressWhereUniqueInput) *AddressExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"AddressWhereUniqueInput!", "Address"},
		"address",
		[]string{"id", "addressName", "state", "city", "country"})

	return &AddressExec{ret}
}

type AddressesParams struct {
	Where   *AddressWhereInput   `json:"where,omitempty"`
	OrderBy *AddressOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) Addresses(params *AddressesParams) *AddressExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"AddressWhereInput", "AddressOrderByInput", "Address"},
		"addresses",
		[]string{"id", "addressName", "state", "city", "country"})

	return &AddressExecArray{ret}
}

type AddressesConnectionParams struct {
	Where   *AddressWhereInput   `json:"where,omitempty"`
	OrderBy *AddressOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32               `json:"skip,omitempty"`
	After   *string              `json:"after,omitempty"`
	Before  *string              `json:"before,omitempty"`
	First   *int32               `json:"first,omitempty"`
	Last    *int32               `json:"last,omitempty"`
}

func (client *Client) AddressesConnection(params *AddressesConnectionParams) AddressConnectionExec {
	panic("not implemented")
}

func (client *Client) Image(params ImageWhereUniqueInput) *ImageExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"ImageWhereUniqueInput!", "Image"},
		"image",
		[]string{"id", "name"})

	return &ImageExec{ret}
}

type ImagesParams struct {
	Where   *ImageWhereInput   `json:"where,omitempty"`
	OrderBy *ImageOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) Images(params *ImagesParams) *ImageExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"ImageWhereInput", "ImageOrderByInput", "Image"},
		"images",
		[]string{"id", "name"})

	return &ImageExecArray{ret}
}

type ImagesConnectionParams struct {
	Where   *ImageWhereInput   `json:"where,omitempty"`
	OrderBy *ImageOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32             `json:"skip,omitempty"`
	After   *string            `json:"after,omitempty"`
	Before  *string            `json:"before,omitempty"`
	First   *int32             `json:"first,omitempty"`
	Last    *int32             `json:"last,omitempty"`
}

func (client *Client) ImagesConnection(params *ImagesConnectionParams) ImageConnectionExec {
	panic("not implemented")
}

func (client *Client) User(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.GetOne(
		nil,
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"user",
		[]string{"id", "email", "firstName", "lastName", "userName", "gender", "isAdmin", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

type UsersParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) Users(params *UsersParams) *UserExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := client.Client.GetMany(
		nil,
		wparams,
		[3]string{"UserWhereInput", "UserOrderByInput", "User"},
		"users",
		[]string{"id", "email", "firstName", "lastName", "userName", "gender", "isAdmin", "createdAt", "updatedAt"})

	return &UserExecArray{ret}
}

type UsersConnectionParams struct {
	Where   *UserWhereInput   `json:"where,omitempty"`
	OrderBy *UserOrderByInput `json:"orderBy,omitempty"`
	Skip    *int32            `json:"skip,omitempty"`
	After   *string           `json:"after,omitempty"`
	Before  *string           `json:"before,omitempty"`
	First   *int32            `json:"first,omitempty"`
	Last    *int32            `json:"last,omitempty"`
}

func (client *Client) UsersConnection(params *UsersConnectionParams) UserConnectionExec {
	panic("not implemented")
}

func (client *Client) CreateAddress(params AddressCreateInput) *AddressExec {
	ret := client.Client.Create(
		params,
		[2]string{"AddressCreateInput!", "Address"},
		"createAddress",
		[]string{"id", "addressName", "state", "city", "country"})

	return &AddressExec{ret}
}

type AddressUpdateParams struct {
	Data  AddressUpdateInput      `json:"data"`
	Where AddressWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateAddress(params AddressUpdateParams) *AddressExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"AddressUpdateInput!", "AddressWhereUniqueInput!", "Address"},
		"updateAddress",
		[]string{"id", "addressName", "state", "city", "country"})

	return &AddressExec{ret}
}

type AddressUpdateManyParams struct {
	Data  AddressUpdateManyMutationInput `json:"data"`
	Where *AddressWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyAddresses(params AddressUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"AddressUpdateManyMutationInput!", "AddressWhereInput"},
		"updateManyAddresses")
	return &BatchPayloadExec{exec}
}

type AddressUpsertParams struct {
	Where  AddressWhereUniqueInput `json:"where"`
	Create AddressCreateInput      `json:"create"`
	Update AddressUpdateInput      `json:"update"`
}

func (client *Client) UpsertAddress(params AddressUpsertParams) *AddressExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"AddressWhereUniqueInput!", "AddressCreateInput!", "AddressUpdateInput!", "Address"},
		"upsertAddress",
		[]string{"id", "addressName", "state", "city", "country"})

	return &AddressExec{ret}
}

func (client *Client) DeleteAddress(params AddressWhereUniqueInput) *AddressExec {
	ret := client.Client.Delete(
		params,
		[2]string{"AddressWhereUniqueInput!", "Address"},
		"deleteAddress",
		[]string{"id", "addressName", "state", "city", "country"})

	return &AddressExec{ret}
}

func (client *Client) DeleteManyAddresses(params *AddressWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "AddressWhereInput", "deleteManyAddresses")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateImage(params ImageCreateInput) *ImageExec {
	ret := client.Client.Create(
		params,
		[2]string{"ImageCreateInput!", "Image"},
		"createImage",
		[]string{"id", "name"})

	return &ImageExec{ret}
}

type ImageUpdateParams struct {
	Data  ImageUpdateInput      `json:"data"`
	Where ImageWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateImage(params ImageUpdateParams) *ImageExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"ImageUpdateInput!", "ImageWhereUniqueInput!", "Image"},
		"updateImage",
		[]string{"id", "name"})

	return &ImageExec{ret}
}

type ImageUpdateManyParams struct {
	Data  ImageUpdateManyMutationInput `json:"data"`
	Where *ImageWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyImages(params ImageUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"ImageUpdateManyMutationInput!", "ImageWhereInput"},
		"updateManyImages")
	return &BatchPayloadExec{exec}
}

type ImageUpsertParams struct {
	Where  ImageWhereUniqueInput `json:"where"`
	Create ImageCreateInput      `json:"create"`
	Update ImageUpdateInput      `json:"update"`
}

func (client *Client) UpsertImage(params ImageUpsertParams) *ImageExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"ImageWhereUniqueInput!", "ImageCreateInput!", "ImageUpdateInput!", "Image"},
		"upsertImage",
		[]string{"id", "name"})

	return &ImageExec{ret}
}

func (client *Client) DeleteImage(params ImageWhereUniqueInput) *ImageExec {
	ret := client.Client.Delete(
		params,
		[2]string{"ImageWhereUniqueInput!", "Image"},
		"deleteImage",
		[]string{"id", "name"})

	return &ImageExec{ret}
}

func (client *Client) DeleteManyImages(params *ImageWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "ImageWhereInput", "deleteManyImages")
	return &BatchPayloadExec{exec}
}

func (client *Client) CreateUser(params UserCreateInput) *UserExec {
	ret := client.Client.Create(
		params,
		[2]string{"UserCreateInput!", "User"},
		"createUser",
		[]string{"id", "email", "firstName", "lastName", "userName", "gender", "isAdmin", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

type UserUpdateParams struct {
	Data  UserUpdateInput      `json:"data"`
	Where UserWhereUniqueInput `json:"where"`
}

func (client *Client) UpdateUser(params UserUpdateParams) *UserExec {
	ret := client.Client.Update(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[3]string{"UserUpdateInput!", "UserWhereUniqueInput!", "User"},
		"updateUser",
		[]string{"id", "email", "firstName", "lastName", "userName", "gender", "isAdmin", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

type UserUpdateManyParams struct {
	Data  UserUpdateManyMutationInput `json:"data"`
	Where *UserWhereInput             `json:"where,omitempty"`
}

func (client *Client) UpdateManyUsers(params UserUpdateManyParams) *BatchPayloadExec {
	exec := client.Client.UpdateMany(
		prisma.UpdateParams{
			Data:  params.Data,
			Where: params.Where,
		},
		[2]string{"UserUpdateManyMutationInput!", "UserWhereInput"},
		"updateManyUsers")
	return &BatchPayloadExec{exec}
}

type UserUpsertParams struct {
	Where  UserWhereUniqueInput `json:"where"`
	Create UserCreateInput      `json:"create"`
	Update UserUpdateInput      `json:"update"`
}

func (client *Client) UpsertUser(params UserUpsertParams) *UserExec {
	uparams := &prisma.UpsertParams{
		Where:  params.Where,
		Create: params.Create,
		Update: params.Update,
	}
	ret := client.Client.Upsert(
		uparams,
		[4]string{"UserWhereUniqueInput!", "UserCreateInput!", "UserUpdateInput!", "User"},
		"upsertUser",
		[]string{"id", "email", "firstName", "lastName", "userName", "gender", "isAdmin", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

func (client *Client) DeleteUser(params UserWhereUniqueInput) *UserExec {
	ret := client.Client.Delete(
		params,
		[2]string{"UserWhereUniqueInput!", "User"},
		"deleteUser",
		[]string{"id", "email", "firstName", "lastName", "userName", "gender", "isAdmin", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

func (client *Client) DeleteManyUsers(params *UserWhereInput) *BatchPayloadExec {
	exec := client.Client.DeleteMany(params, "UserWhereInput", "deleteManyUsers")
	return &BatchPayloadExec{exec}
}

type ImageOrderByInput string

const (
	ImageOrderByInputIDAsc         ImageOrderByInput = "id_ASC"
	ImageOrderByInputIDDesc        ImageOrderByInput = "id_DESC"
	ImageOrderByInputNameAsc       ImageOrderByInput = "name_ASC"
	ImageOrderByInputNameDesc      ImageOrderByInput = "name_DESC"
	ImageOrderByInputCreatedAtAsc  ImageOrderByInput = "createdAt_ASC"
	ImageOrderByInputCreatedAtDesc ImageOrderByInput = "createdAt_DESC"
	ImageOrderByInputUpdatedAtAsc  ImageOrderByInput = "updatedAt_ASC"
	ImageOrderByInputUpdatedAtDesc ImageOrderByInput = "updatedAt_DESC"
)

type AddressOrderByInput string

const (
	AddressOrderByInputIDAsc           AddressOrderByInput = "id_ASC"
	AddressOrderByInputIDDesc          AddressOrderByInput = "id_DESC"
	AddressOrderByInputAddressNameAsc  AddressOrderByInput = "addressName_ASC"
	AddressOrderByInputAddressNameDesc AddressOrderByInput = "addressName_DESC"
	AddressOrderByInputStateAsc        AddressOrderByInput = "state_ASC"
	AddressOrderByInputStateDesc       AddressOrderByInput = "state_DESC"
	AddressOrderByInputCityAsc         AddressOrderByInput = "city_ASC"
	AddressOrderByInputCityDesc        AddressOrderByInput = "city_DESC"
	AddressOrderByInputCountryAsc      AddressOrderByInput = "country_ASC"
	AddressOrderByInputCountryDesc     AddressOrderByInput = "country_DESC"
	AddressOrderByInputCreatedAtAsc    AddressOrderByInput = "createdAt_ASC"
	AddressOrderByInputCreatedAtDesc   AddressOrderByInput = "createdAt_DESC"
	AddressOrderByInputUpdatedAtAsc    AddressOrderByInput = "updatedAt_ASC"
	AddressOrderByInputUpdatedAtDesc   AddressOrderByInput = "updatedAt_DESC"
)

type UserOrderByInput string

const (
	UserOrderByInputIDAsc         UserOrderByInput = "id_ASC"
	UserOrderByInputIDDesc        UserOrderByInput = "id_DESC"
	UserOrderByInputEmailAsc      UserOrderByInput = "email_ASC"
	UserOrderByInputEmailDesc     UserOrderByInput = "email_DESC"
	UserOrderByInputFirstNameAsc  UserOrderByInput = "firstName_ASC"
	UserOrderByInputFirstNameDesc UserOrderByInput = "firstName_DESC"
	UserOrderByInputLastNameAsc   UserOrderByInput = "lastName_ASC"
	UserOrderByInputLastNameDesc  UserOrderByInput = "lastName_DESC"
	UserOrderByInputUserNameAsc   UserOrderByInput = "userName_ASC"
	UserOrderByInputUserNameDesc  UserOrderByInput = "userName_DESC"
	UserOrderByInputGenderAsc     UserOrderByInput = "gender_ASC"
	UserOrderByInputGenderDesc    UserOrderByInput = "gender_DESC"
	UserOrderByInputIsAdminAsc    UserOrderByInput = "isAdmin_ASC"
	UserOrderByInputIsAdminDesc   UserOrderByInput = "isAdmin_DESC"
	UserOrderByInputCreatedAtAsc  UserOrderByInput = "createdAt_ASC"
	UserOrderByInputCreatedAtDesc UserOrderByInput = "createdAt_DESC"
	UserOrderByInputUpdatedAtAsc  UserOrderByInput = "updatedAt_ASC"
	UserOrderByInputUpdatedAtDesc UserOrderByInput = "updatedAt_DESC"
)

type MutationType string

const (
	MutationTypeCreated MutationType = "CREATED"
	MutationTypeUpdated MutationType = "UPDATED"
	MutationTypeDeleted MutationType = "DELETED"
)

type AddressWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type ImageWhereInput struct {
	ID                *string           `json:"id,omitempty"`
	IDNot             *string           `json:"id_not,omitempty"`
	IDIn              []string          `json:"id_in,omitempty"`
	IDNotIn           []string          `json:"id_not_in,omitempty"`
	IDLt              *string           `json:"id_lt,omitempty"`
	IDLte             *string           `json:"id_lte,omitempty"`
	IDGt              *string           `json:"id_gt,omitempty"`
	IDGte             *string           `json:"id_gte,omitempty"`
	IDContains        *string           `json:"id_contains,omitempty"`
	IDNotContains     *string           `json:"id_not_contains,omitempty"`
	IDStartsWith      *string           `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string           `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string           `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string           `json:"id_not_ends_with,omitempty"`
	Name              *string           `json:"name,omitempty"`
	NameNot           *string           `json:"name_not,omitempty"`
	NameIn            []string          `json:"name_in,omitempty"`
	NameNotIn         []string          `json:"name_not_in,omitempty"`
	NameLt            *string           `json:"name_lt,omitempty"`
	NameLte           *string           `json:"name_lte,omitempty"`
	NameGt            *string           `json:"name_gt,omitempty"`
	NameGte           *string           `json:"name_gte,omitempty"`
	NameContains      *string           `json:"name_contains,omitempty"`
	NameNotContains   *string           `json:"name_not_contains,omitempty"`
	NameStartsWith    *string           `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string           `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string           `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string           `json:"name_not_ends_with,omitempty"`
	UserImage         *UserWhereInput   `json:"userImage,omitempty"`
	And               []ImageWhereInput `json:"AND,omitempty"`
	Or                []ImageWhereInput `json:"OR,omitempty"`
	Not               []ImageWhereInput `json:"NOT,omitempty"`
}

type UserWhereInput struct {
	ID                     *string            `json:"id,omitempty"`
	IDNot                  *string            `json:"id_not,omitempty"`
	IDIn                   []string           `json:"id_in,omitempty"`
	IDNotIn                []string           `json:"id_not_in,omitempty"`
	IDLt                   *string            `json:"id_lt,omitempty"`
	IDLte                  *string            `json:"id_lte,omitempty"`
	IDGt                   *string            `json:"id_gt,omitempty"`
	IDGte                  *string            `json:"id_gte,omitempty"`
	IDContains             *string            `json:"id_contains,omitempty"`
	IDNotContains          *string            `json:"id_not_contains,omitempty"`
	IDStartsWith           *string            `json:"id_starts_with,omitempty"`
	IDNotStartsWith        *string            `json:"id_not_starts_with,omitempty"`
	IDEndsWith             *string            `json:"id_ends_with,omitempty"`
	IDNotEndsWith          *string            `json:"id_not_ends_with,omitempty"`
	Email                  *string            `json:"email,omitempty"`
	EmailNot               *string            `json:"email_not,omitempty"`
	EmailIn                []string           `json:"email_in,omitempty"`
	EmailNotIn             []string           `json:"email_not_in,omitempty"`
	EmailLt                *string            `json:"email_lt,omitempty"`
	EmailLte               *string            `json:"email_lte,omitempty"`
	EmailGt                *string            `json:"email_gt,omitempty"`
	EmailGte               *string            `json:"email_gte,omitempty"`
	EmailContains          *string            `json:"email_contains,omitempty"`
	EmailNotContains       *string            `json:"email_not_contains,omitempty"`
	EmailStartsWith        *string            `json:"email_starts_with,omitempty"`
	EmailNotStartsWith     *string            `json:"email_not_starts_with,omitempty"`
	EmailEndsWith          *string            `json:"email_ends_with,omitempty"`
	EmailNotEndsWith       *string            `json:"email_not_ends_with,omitempty"`
	FirstName              *string            `json:"firstName,omitempty"`
	FirstNameNot           *string            `json:"firstName_not,omitempty"`
	FirstNameIn            []string           `json:"firstName_in,omitempty"`
	FirstNameNotIn         []string           `json:"firstName_not_in,omitempty"`
	FirstNameLt            *string            `json:"firstName_lt,omitempty"`
	FirstNameLte           *string            `json:"firstName_lte,omitempty"`
	FirstNameGt            *string            `json:"firstName_gt,omitempty"`
	FirstNameGte           *string            `json:"firstName_gte,omitempty"`
	FirstNameContains      *string            `json:"firstName_contains,omitempty"`
	FirstNameNotContains   *string            `json:"firstName_not_contains,omitempty"`
	FirstNameStartsWith    *string            `json:"firstName_starts_with,omitempty"`
	FirstNameNotStartsWith *string            `json:"firstName_not_starts_with,omitempty"`
	FirstNameEndsWith      *string            `json:"firstName_ends_with,omitempty"`
	FirstNameNotEndsWith   *string            `json:"firstName_not_ends_with,omitempty"`
	LastName               *string            `json:"lastName,omitempty"`
	LastNameNot            *string            `json:"lastName_not,omitempty"`
	LastNameIn             []string           `json:"lastName_in,omitempty"`
	LastNameNotIn          []string           `json:"lastName_not_in,omitempty"`
	LastNameLt             *string            `json:"lastName_lt,omitempty"`
	LastNameLte            *string            `json:"lastName_lte,omitempty"`
	LastNameGt             *string            `json:"lastName_gt,omitempty"`
	LastNameGte            *string            `json:"lastName_gte,omitempty"`
	LastNameContains       *string            `json:"lastName_contains,omitempty"`
	LastNameNotContains    *string            `json:"lastName_not_contains,omitempty"`
	LastNameStartsWith     *string            `json:"lastName_starts_with,omitempty"`
	LastNameNotStartsWith  *string            `json:"lastName_not_starts_with,omitempty"`
	LastNameEndsWith       *string            `json:"lastName_ends_with,omitempty"`
	LastNameNotEndsWith    *string            `json:"lastName_not_ends_with,omitempty"`
	UserName               *string            `json:"userName,omitempty"`
	UserNameNot            *string            `json:"userName_not,omitempty"`
	UserNameIn             []string           `json:"userName_in,omitempty"`
	UserNameNotIn          []string           `json:"userName_not_in,omitempty"`
	UserNameLt             *string            `json:"userName_lt,omitempty"`
	UserNameLte            *string            `json:"userName_lte,omitempty"`
	UserNameGt             *string            `json:"userName_gt,omitempty"`
	UserNameGte            *string            `json:"userName_gte,omitempty"`
	UserNameContains       *string            `json:"userName_contains,omitempty"`
	UserNameNotContains    *string            `json:"userName_not_contains,omitempty"`
	UserNameStartsWith     *string            `json:"userName_starts_with,omitempty"`
	UserNameNotStartsWith  *string            `json:"userName_not_starts_with,omitempty"`
	UserNameEndsWith       *string            `json:"userName_ends_with,omitempty"`
	UserNameNotEndsWith    *string            `json:"userName_not_ends_with,omitempty"`
	Gender                 *string            `json:"gender,omitempty"`
	GenderNot              *string            `json:"gender_not,omitempty"`
	GenderIn               []string           `json:"gender_in,omitempty"`
	GenderNotIn            []string           `json:"gender_not_in,omitempty"`
	GenderLt               *string            `json:"gender_lt,omitempty"`
	GenderLte              *string            `json:"gender_lte,omitempty"`
	GenderGt               *string            `json:"gender_gt,omitempty"`
	GenderGte              *string            `json:"gender_gte,omitempty"`
	GenderContains         *string            `json:"gender_contains,omitempty"`
	GenderNotContains      *string            `json:"gender_not_contains,omitempty"`
	GenderStartsWith       *string            `json:"gender_starts_with,omitempty"`
	GenderNotStartsWith    *string            `json:"gender_not_starts_with,omitempty"`
	GenderEndsWith         *string            `json:"gender_ends_with,omitempty"`
	GenderNotEndsWith      *string            `json:"gender_not_ends_with,omitempty"`
	ImagesEvery            *ImageWhereInput   `json:"images_every,omitempty"`
	ImagesSome             *ImageWhereInput   `json:"images_some,omitempty"`
	ImagesNone             *ImageWhereInput   `json:"images_none,omitempty"`
	IsAdmin                *bool              `json:"isAdmin,omitempty"`
	IsAdminNot             *bool              `json:"isAdmin_not,omitempty"`
	Address                *AddressWhereInput `json:"address,omitempty"`
	CreatedAt              *string            `json:"createdAt,omitempty"`
	CreatedAtNot           *string            `json:"createdAt_not,omitempty"`
	CreatedAtIn            []string           `json:"createdAt_in,omitempty"`
	CreatedAtNotIn         []string           `json:"createdAt_not_in,omitempty"`
	CreatedAtLt            *string            `json:"createdAt_lt,omitempty"`
	CreatedAtLte           *string            `json:"createdAt_lte,omitempty"`
	CreatedAtGt            *string            `json:"createdAt_gt,omitempty"`
	CreatedAtGte           *string            `json:"createdAt_gte,omitempty"`
	UpdatedAt              *string            `json:"updatedAt,omitempty"`
	UpdatedAtNot           *string            `json:"updatedAt_not,omitempty"`
	UpdatedAtIn            []string           `json:"updatedAt_in,omitempty"`
	UpdatedAtNotIn         []string           `json:"updatedAt_not_in,omitempty"`
	UpdatedAtLt            *string            `json:"updatedAt_lt,omitempty"`
	UpdatedAtLte           *string            `json:"updatedAt_lte,omitempty"`
	UpdatedAtGt            *string            `json:"updatedAt_gt,omitempty"`
	UpdatedAtGte           *string            `json:"updatedAt_gte,omitempty"`
	And                    []UserWhereInput   `json:"AND,omitempty"`
	Or                     []UserWhereInput   `json:"OR,omitempty"`
	Not                    []UserWhereInput   `json:"NOT,omitempty"`
}

type AddressWhereInput struct {
	ID                       *string             `json:"id,omitempty"`
	IDNot                    *string             `json:"id_not,omitempty"`
	IDIn                     []string            `json:"id_in,omitempty"`
	IDNotIn                  []string            `json:"id_not_in,omitempty"`
	IDLt                     *string             `json:"id_lt,omitempty"`
	IDLte                    *string             `json:"id_lte,omitempty"`
	IDGt                     *string             `json:"id_gt,omitempty"`
	IDGte                    *string             `json:"id_gte,omitempty"`
	IDContains               *string             `json:"id_contains,omitempty"`
	IDNotContains            *string             `json:"id_not_contains,omitempty"`
	IDStartsWith             *string             `json:"id_starts_with,omitempty"`
	IDNotStartsWith          *string             `json:"id_not_starts_with,omitempty"`
	IDEndsWith               *string             `json:"id_ends_with,omitempty"`
	IDNotEndsWith            *string             `json:"id_not_ends_with,omitempty"`
	AddressName              *string             `json:"addressName,omitempty"`
	AddressNameNot           *string             `json:"addressName_not,omitempty"`
	AddressNameIn            []string            `json:"addressName_in,omitempty"`
	AddressNameNotIn         []string            `json:"addressName_not_in,omitempty"`
	AddressNameLt            *string             `json:"addressName_lt,omitempty"`
	AddressNameLte           *string             `json:"addressName_lte,omitempty"`
	AddressNameGt            *string             `json:"addressName_gt,omitempty"`
	AddressNameGte           *string             `json:"addressName_gte,omitempty"`
	AddressNameContains      *string             `json:"addressName_contains,omitempty"`
	AddressNameNotContains   *string             `json:"addressName_not_contains,omitempty"`
	AddressNameStartsWith    *string             `json:"addressName_starts_with,omitempty"`
	AddressNameNotStartsWith *string             `json:"addressName_not_starts_with,omitempty"`
	AddressNameEndsWith      *string             `json:"addressName_ends_with,omitempty"`
	AddressNameNotEndsWith   *string             `json:"addressName_not_ends_with,omitempty"`
	State                    *string             `json:"state,omitempty"`
	StateNot                 *string             `json:"state_not,omitempty"`
	StateIn                  []string            `json:"state_in,omitempty"`
	StateNotIn               []string            `json:"state_not_in,omitempty"`
	StateLt                  *string             `json:"state_lt,omitempty"`
	StateLte                 *string             `json:"state_lte,omitempty"`
	StateGt                  *string             `json:"state_gt,omitempty"`
	StateGte                 *string             `json:"state_gte,omitempty"`
	StateContains            *string             `json:"state_contains,omitempty"`
	StateNotContains         *string             `json:"state_not_contains,omitempty"`
	StateStartsWith          *string             `json:"state_starts_with,omitempty"`
	StateNotStartsWith       *string             `json:"state_not_starts_with,omitempty"`
	StateEndsWith            *string             `json:"state_ends_with,omitempty"`
	StateNotEndsWith         *string             `json:"state_not_ends_with,omitempty"`
	City                     *string             `json:"city,omitempty"`
	CityNot                  *string             `json:"city_not,omitempty"`
	CityIn                   []string            `json:"city_in,omitempty"`
	CityNotIn                []string            `json:"city_not_in,omitempty"`
	CityLt                   *string             `json:"city_lt,omitempty"`
	CityLte                  *string             `json:"city_lte,omitempty"`
	CityGt                   *string             `json:"city_gt,omitempty"`
	CityGte                  *string             `json:"city_gte,omitempty"`
	CityContains             *string             `json:"city_contains,omitempty"`
	CityNotContains          *string             `json:"city_not_contains,omitempty"`
	CityStartsWith           *string             `json:"city_starts_with,omitempty"`
	CityNotStartsWith        *string             `json:"city_not_starts_with,omitempty"`
	CityEndsWith             *string             `json:"city_ends_with,omitempty"`
	CityNotEndsWith          *string             `json:"city_not_ends_with,omitempty"`
	Country                  *string             `json:"country,omitempty"`
	CountryNot               *string             `json:"country_not,omitempty"`
	CountryIn                []string            `json:"country_in,omitempty"`
	CountryNotIn             []string            `json:"country_not_in,omitempty"`
	CountryLt                *string             `json:"country_lt,omitempty"`
	CountryLte               *string             `json:"country_lte,omitempty"`
	CountryGt                *string             `json:"country_gt,omitempty"`
	CountryGte               *string             `json:"country_gte,omitempty"`
	CountryContains          *string             `json:"country_contains,omitempty"`
	CountryNotContains       *string             `json:"country_not_contains,omitempty"`
	CountryStartsWith        *string             `json:"country_starts_with,omitempty"`
	CountryNotStartsWith     *string             `json:"country_not_starts_with,omitempty"`
	CountryEndsWith          *string             `json:"country_ends_with,omitempty"`
	CountryNotEndsWith       *string             `json:"country_not_ends_with,omitempty"`
	UserAddress              *UserWhereInput     `json:"userAddress,omitempty"`
	And                      []AddressWhereInput `json:"AND,omitempty"`
	Or                       []AddressWhereInput `json:"OR,omitempty"`
	Not                      []AddressWhereInput `json:"NOT,omitempty"`
}

type ImageWhereUniqueInput struct {
	ID *string `json:"id,omitempty"`
}

type UserWhereUniqueInput struct {
	ID    *string `json:"id,omitempty"`
	Email *string `json:"email,omitempty"`
}

type AddressCreateInput struct {
	AddressName string                            `json:"addressName"`
	State       string                            `json:"state"`
	City        *string                           `json:"city,omitempty"`
	Country     *string                           `json:"country,omitempty"`
	UserAddress *UserCreateOneWithoutAddressInput `json:"userAddress,omitempty"`
}

type UserCreateOneWithoutAddressInput struct {
	Create  *UserCreateWithoutAddressInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput          `json:"connect,omitempty"`
}

type UserCreateWithoutAddressInput struct {
	Email     string                                `json:"email"`
	FirstName string                                `json:"firstName"`
	LastName  string                                `json:"lastName"`
	UserName  string                                `json:"userName"`
	Gender    string                                `json:"gender"`
	Images    *ImageCreateManyWithoutUserImageInput `json:"images,omitempty"`
	IsAdmin   *bool                                 `json:"isAdmin,omitempty"`
}

type ImageCreateManyWithoutUserImageInput struct {
	Create  []ImageCreateWithoutUserImageInput `json:"create,omitempty"`
	Connect []ImageWhereUniqueInput            `json:"connect,omitempty"`
}

type ImageCreateWithoutUserImageInput struct {
	Name string `json:"name"`
}

type AddressUpdateInput struct {
	AddressName *string                           `json:"addressName,omitempty"`
	State       *string                           `json:"state,omitempty"`
	City        *string                           `json:"city,omitempty"`
	Country     *string                           `json:"country,omitempty"`
	UserAddress *UserUpdateOneWithoutAddressInput `json:"userAddress,omitempty"`
}

type UserUpdateOneWithoutAddressInput struct {
	Create     *UserCreateWithoutAddressInput     `json:"create,omitempty"`
	Update     *UserUpdateWithoutAddressDataInput `json:"update,omitempty"`
	Upsert     *UserUpsertWithoutAddressInput     `json:"upsert,omitempty"`
	Delete     *bool                              `json:"delete,omitempty"`
	Disconnect *bool                              `json:"disconnect,omitempty"`
	Connect    *UserWhereUniqueInput              `json:"connect,omitempty"`
}

type UserUpdateWithoutAddressDataInput struct {
	Email     *string                               `json:"email,omitempty"`
	FirstName *string                               `json:"firstName,omitempty"`
	LastName  *string                               `json:"lastName,omitempty"`
	UserName  *string                               `json:"userName,omitempty"`
	Gender    *string                               `json:"gender,omitempty"`
	Images    *ImageUpdateManyWithoutUserImageInput `json:"images,omitempty"`
	IsAdmin   *bool                                 `json:"isAdmin,omitempty"`
}

type ImageUpdateManyWithoutUserImageInput struct {
	Create     []ImageCreateWithoutUserImageInput                `json:"create,omitempty"`
	Delete     []ImageWhereUniqueInput                           `json:"delete,omitempty"`
	Connect    []ImageWhereUniqueInput                           `json:"connect,omitempty"`
	Set        []ImageWhereUniqueInput                           `json:"set,omitempty"`
	Disconnect []ImageWhereUniqueInput                           `json:"disconnect,omitempty"`
	Update     []ImageUpdateWithWhereUniqueWithoutUserImageInput `json:"update,omitempty"`
	Upsert     []ImageUpsertWithWhereUniqueWithoutUserImageInput `json:"upsert,omitempty"`
	DeleteMany []ImageScalarWhereInput                           `json:"deleteMany,omitempty"`
	UpdateMany []ImageUpdateManyWithWhereNestedInput             `json:"updateMany,omitempty"`
}

type ImageUpdateWithWhereUniqueWithoutUserImageInput struct {
	Where ImageWhereUniqueInput                `json:"where"`
	Data  ImageUpdateWithoutUserImageDataInput `json:"data"`
}

type ImageUpdateWithoutUserImageDataInput struct {
	Name *string `json:"name,omitempty"`
}

type ImageUpsertWithWhereUniqueWithoutUserImageInput struct {
	Where  ImageWhereUniqueInput                `json:"where"`
	Update ImageUpdateWithoutUserImageDataInput `json:"update"`
	Create ImageCreateWithoutUserImageInput     `json:"create"`
}

type ImageScalarWhereInput struct {
	ID                *string                 `json:"id,omitempty"`
	IDNot             *string                 `json:"id_not,omitempty"`
	IDIn              []string                `json:"id_in,omitempty"`
	IDNotIn           []string                `json:"id_not_in,omitempty"`
	IDLt              *string                 `json:"id_lt,omitempty"`
	IDLte             *string                 `json:"id_lte,omitempty"`
	IDGt              *string                 `json:"id_gt,omitempty"`
	IDGte             *string                 `json:"id_gte,omitempty"`
	IDContains        *string                 `json:"id_contains,omitempty"`
	IDNotContains     *string                 `json:"id_not_contains,omitempty"`
	IDStartsWith      *string                 `json:"id_starts_with,omitempty"`
	IDNotStartsWith   *string                 `json:"id_not_starts_with,omitempty"`
	IDEndsWith        *string                 `json:"id_ends_with,omitempty"`
	IDNotEndsWith     *string                 `json:"id_not_ends_with,omitempty"`
	Name              *string                 `json:"name,omitempty"`
	NameNot           *string                 `json:"name_not,omitempty"`
	NameIn            []string                `json:"name_in,omitempty"`
	NameNotIn         []string                `json:"name_not_in,omitempty"`
	NameLt            *string                 `json:"name_lt,omitempty"`
	NameLte           *string                 `json:"name_lte,omitempty"`
	NameGt            *string                 `json:"name_gt,omitempty"`
	NameGte           *string                 `json:"name_gte,omitempty"`
	NameContains      *string                 `json:"name_contains,omitempty"`
	NameNotContains   *string                 `json:"name_not_contains,omitempty"`
	NameStartsWith    *string                 `json:"name_starts_with,omitempty"`
	NameNotStartsWith *string                 `json:"name_not_starts_with,omitempty"`
	NameEndsWith      *string                 `json:"name_ends_with,omitempty"`
	NameNotEndsWith   *string                 `json:"name_not_ends_with,omitempty"`
	And               []ImageScalarWhereInput `json:"AND,omitempty"`
	Or                []ImageScalarWhereInput `json:"OR,omitempty"`
	Not               []ImageScalarWhereInput `json:"NOT,omitempty"`
}

type ImageUpdateManyWithWhereNestedInput struct {
	Where ImageScalarWhereInput    `json:"where"`
	Data  ImageUpdateManyDataInput `json:"data"`
}

type ImageUpdateManyDataInput struct {
	Name *string `json:"name,omitempty"`
}

type UserUpsertWithoutAddressInput struct {
	Update UserUpdateWithoutAddressDataInput `json:"update"`
	Create UserCreateWithoutAddressInput     `json:"create"`
}

type AddressUpdateManyMutationInput struct {
	AddressName *string `json:"addressName,omitempty"`
	State       *string `json:"state,omitempty"`
	City        *string `json:"city,omitempty"`
	Country     *string `json:"country,omitempty"`
}

type ImageCreateInput struct {
	Name      string                           `json:"name"`
	UserImage *UserCreateOneWithoutImagesInput `json:"userImage,omitempty"`
}

type UserCreateOneWithoutImagesInput struct {
	Create  *UserCreateWithoutImagesInput `json:"create,omitempty"`
	Connect *UserWhereUniqueInput         `json:"connect,omitempty"`
}

type UserCreateWithoutImagesInput struct {
	Email     string                                   `json:"email"`
	FirstName string                                   `json:"firstName"`
	LastName  string                                   `json:"lastName"`
	UserName  string                                   `json:"userName"`
	Gender    string                                   `json:"gender"`
	IsAdmin   *bool                                    `json:"isAdmin,omitempty"`
	Address   *AddressCreateOneWithoutUserAddressInput `json:"address,omitempty"`
}

type AddressCreateOneWithoutUserAddressInput struct {
	Create  *AddressCreateWithoutUserAddressInput `json:"create,omitempty"`
	Connect *AddressWhereUniqueInput              `json:"connect,omitempty"`
}

type AddressCreateWithoutUserAddressInput struct {
	AddressName string  `json:"addressName"`
	State       string  `json:"state"`
	City        *string `json:"city,omitempty"`
	Country     *string `json:"country,omitempty"`
}

type ImageUpdateInput struct {
	Name      *string                          `json:"name,omitempty"`
	UserImage *UserUpdateOneWithoutImagesInput `json:"userImage,omitempty"`
}

type UserUpdateOneWithoutImagesInput struct {
	Create     *UserCreateWithoutImagesInput     `json:"create,omitempty"`
	Update     *UserUpdateWithoutImagesDataInput `json:"update,omitempty"`
	Upsert     *UserUpsertWithoutImagesInput     `json:"upsert,omitempty"`
	Delete     *bool                             `json:"delete,omitempty"`
	Disconnect *bool                             `json:"disconnect,omitempty"`
	Connect    *UserWhereUniqueInput             `json:"connect,omitempty"`
}

type UserUpdateWithoutImagesDataInput struct {
	Email     *string                                  `json:"email,omitempty"`
	FirstName *string                                  `json:"firstName,omitempty"`
	LastName  *string                                  `json:"lastName,omitempty"`
	UserName  *string                                  `json:"userName,omitempty"`
	Gender    *string                                  `json:"gender,omitempty"`
	IsAdmin   *bool                                    `json:"isAdmin,omitempty"`
	Address   *AddressUpdateOneWithoutUserAddressInput `json:"address,omitempty"`
}

type AddressUpdateOneWithoutUserAddressInput struct {
	Create     *AddressCreateWithoutUserAddressInput     `json:"create,omitempty"`
	Update     *AddressUpdateWithoutUserAddressDataInput `json:"update,omitempty"`
	Upsert     *AddressUpsertWithoutUserAddressInput     `json:"upsert,omitempty"`
	Delete     *bool                                     `json:"delete,omitempty"`
	Disconnect *bool                                     `json:"disconnect,omitempty"`
	Connect    *AddressWhereUniqueInput                  `json:"connect,omitempty"`
}

type AddressUpdateWithoutUserAddressDataInput struct {
	AddressName *string `json:"addressName,omitempty"`
	State       *string `json:"state,omitempty"`
	City        *string `json:"city,omitempty"`
	Country     *string `json:"country,omitempty"`
}

type AddressUpsertWithoutUserAddressInput struct {
	Update AddressUpdateWithoutUserAddressDataInput `json:"update"`
	Create AddressCreateWithoutUserAddressInput     `json:"create"`
}

type UserUpsertWithoutImagesInput struct {
	Update UserUpdateWithoutImagesDataInput `json:"update"`
	Create UserCreateWithoutImagesInput     `json:"create"`
}

type ImageUpdateManyMutationInput struct {
	Name *string `json:"name,omitempty"`
}

type UserCreateInput struct {
	Email     string                                   `json:"email"`
	FirstName string                                   `json:"firstName"`
	LastName  string                                   `json:"lastName"`
	UserName  string                                   `json:"userName"`
	Gender    string                                   `json:"gender"`
	Images    *ImageCreateManyWithoutUserImageInput    `json:"images,omitempty"`
	IsAdmin   *bool                                    `json:"isAdmin,omitempty"`
	Address   *AddressCreateOneWithoutUserAddressInput `json:"address,omitempty"`
}

type UserUpdateInput struct {
	Email     *string                                  `json:"email,omitempty"`
	FirstName *string                                  `json:"firstName,omitempty"`
	LastName  *string                                  `json:"lastName,omitempty"`
	UserName  *string                                  `json:"userName,omitempty"`
	Gender    *string                                  `json:"gender,omitempty"`
	Images    *ImageUpdateManyWithoutUserImageInput    `json:"images,omitempty"`
	IsAdmin   *bool                                    `json:"isAdmin,omitempty"`
	Address   *AddressUpdateOneWithoutUserAddressInput `json:"address,omitempty"`
}

type UserUpdateManyMutationInput struct {
	Email     *string `json:"email,omitempty"`
	FirstName *string `json:"firstName,omitempty"`
	LastName  *string `json:"lastName,omitempty"`
	UserName  *string `json:"userName,omitempty"`
	Gender    *string `json:"gender,omitempty"`
	IsAdmin   *bool   `json:"isAdmin,omitempty"`
}

type AddressSubscriptionWhereInput struct {
	MutationIn                 []MutationType                  `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                         `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                        `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                        `json:"updatedFields_contains_some,omitempty"`
	Node                       *AddressWhereInput              `json:"node,omitempty"`
	And                        []AddressSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []AddressSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []AddressSubscriptionWhereInput `json:"NOT,omitempty"`
}

type ImageSubscriptionWhereInput struct {
	MutationIn                 []MutationType                `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                       `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                      `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                      `json:"updatedFields_contains_some,omitempty"`
	Node                       *ImageWhereInput              `json:"node,omitempty"`
	And                        []ImageSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []ImageSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []ImageSubscriptionWhereInput `json:"NOT,omitempty"`
}

type UserSubscriptionWhereInput struct {
	MutationIn                 []MutationType               `json:"mutation_in,omitempty"`
	UpdatedFieldsContains      *string                      `json:"updatedFields_contains,omitempty"`
	UpdatedFieldsContainsEvery []string                     `json:"updatedFields_contains_every,omitempty"`
	UpdatedFieldsContainsSome  []string                     `json:"updatedFields_contains_some,omitempty"`
	Node                       *UserWhereInput              `json:"node,omitempty"`
	And                        []UserSubscriptionWhereInput `json:"AND,omitempty"`
	Or                         []UserSubscriptionWhereInput `json:"OR,omitempty"`
	Not                        []UserSubscriptionWhereInput `json:"NOT,omitempty"`
}

type AddressExec struct {
	exec *prisma.Exec
}

func (instance *AddressExec) UserAddress() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"userAddress",
		[]string{"id", "email", "firstName", "lastName", "userName", "gender", "isAdmin", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

func (instance AddressExec) Exec(ctx context.Context) (*Address, error) {
	var v Address
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AddressExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AddressExecArray struct {
	exec *prisma.Exec
}

func (instance AddressExecArray) Exec(ctx context.Context) ([]Address, error) {
	var v []Address
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Address struct {
	ID          string `json:"id"`
	AddressName string `json:"addressName"`
	State       string `json:"state"`
	City        string `json:"city"`
	Country     string `json:"country"`
}

type UserExec struct {
	exec *prisma.Exec
}

type ImagesParamsExec struct {
	Where   *ImageWhereInput
	OrderBy *ImageOrderByInput
	Skip    *int32
	After   *string
	Before  *string
	First   *int32
	Last    *int32
}

func (instance *UserExec) Images(params *ImagesParamsExec) *ImageExecArray {
	var wparams *prisma.WhereParams
	if params != nil {
		wparams = &prisma.WhereParams{
			Where:   params.Where,
			OrderBy: (*string)(params.OrderBy),
			Skip:    params.Skip,
			After:   params.After,
			Before:  params.Before,
			First:   params.First,
			Last:    params.Last,
		}
	}

	ret := instance.exec.Client.GetMany(
		instance.exec,
		wparams,
		[3]string{"ImageWhereInput", "ImageOrderByInput", "Image"},
		"images",
		[]string{"id", "name"})

	return &ImageExecArray{ret}
}

func (instance *UserExec) Address() *AddressExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Address"},
		"address",
		[]string{"id", "addressName", "state", "city", "country"})

	return &AddressExec{ret}
}

func (instance UserExec) Exec(ctx context.Context) (*User, error) {
	var v User
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserExecArray struct {
	exec *prisma.Exec
}

func (instance UserExecArray) Exec(ctx context.Context) ([]User, error) {
	var v []User
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type User struct {
	ID        string `json:"id"`
	Email     string `json:"email"`
	FirstName string `json:"firstName"`
	LastName  string `json:"lastName"`
	UserName  string `json:"userName"`
	Gender    string `json:"gender"`
	IsAdmin   bool   `json:"isAdmin"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}

type ImageExec struct {
	exec *prisma.Exec
}

func (instance *ImageExec) UserImage() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"userImage",
		[]string{"id", "email", "firstName", "lastName", "userName", "gender", "isAdmin", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

func (instance ImageExec) Exec(ctx context.Context) (*Image, error) {
	var v Image
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ImageExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ImageExecArray struct {
	exec *prisma.Exec
}

func (instance ImageExecArray) Exec(ctx context.Context) ([]Image, error) {
	var v []Image
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type Image struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type AddressConnectionExec struct {
	exec *prisma.Exec
}

func (instance *AddressConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *AddressConnectionExec) Edges() *AddressEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AddressEdge"},
		"edges",
		[]string{"cursor"})

	return &AddressEdgeExec{ret}
}

func (instance *AddressConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateAddress"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance AddressConnectionExec) Exec(ctx context.Context) (*AddressConnection, error) {
	var v AddressConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AddressConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AddressConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance AddressConnectionExecArray) Exec(ctx context.Context) ([]AddressConnection, error) {
	var v []AddressConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AddressConnection struct {
}

type PageInfoExec struct {
	exec *prisma.Exec
}

func (instance PageInfoExec) Exec(ctx context.Context) (*PageInfo, error) {
	var v PageInfo
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance PageInfoExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type PageInfoExecArray struct {
	exec *prisma.Exec
}

func (instance PageInfoExecArray) Exec(ctx context.Context) ([]PageInfo, error) {
	var v []PageInfo
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor,omitempty"`
	EndCursor       *string `json:"endCursor,omitempty"`
}

type AddressEdgeExec struct {
	exec *prisma.Exec
}

func (instance *AddressEdgeExec) Node() *AddressExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Address"},
		"node",
		[]string{"id", "addressName", "state", "city", "country"})

	return &AddressExec{ret}
}

func (instance AddressEdgeExec) Exec(ctx context.Context) (*AddressEdge, error) {
	var v AddressEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AddressEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AddressEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance AddressEdgeExecArray) Exec(ctx context.Context) ([]AddressEdge, error) {
	var v []AddressEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AddressEdge struct {
	Cursor string `json:"cursor"`
}

type ImageConnectionExec struct {
	exec *prisma.Exec
}

func (instance *ImageConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *ImageConnectionExec) Edges() *ImageEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ImageEdge"},
		"edges",
		[]string{"cursor"})

	return &ImageEdgeExec{ret}
}

func (instance *ImageConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateImage"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance ImageConnectionExec) Exec(ctx context.Context) (*ImageConnection, error) {
	var v ImageConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ImageConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ImageConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance ImageConnectionExecArray) Exec(ctx context.Context) ([]ImageConnection, error) {
	var v []ImageConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ImageConnection struct {
}

type ImageEdgeExec struct {
	exec *prisma.Exec
}

func (instance *ImageEdgeExec) Node() *ImageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Image"},
		"node",
		[]string{"id", "name"})

	return &ImageExec{ret}
}

func (instance ImageEdgeExec) Exec(ctx context.Context) (*ImageEdge, error) {
	var v ImageEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ImageEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ImageEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance ImageEdgeExecArray) Exec(ctx context.Context) ([]ImageEdge, error) {
	var v []ImageEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ImageEdge struct {
	Cursor string `json:"cursor"`
}

type UserConnectionExec struct {
	exec *prisma.Exec
}

func (instance *UserConnectionExec) PageInfo() *PageInfoExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "PageInfo"},
		"pageInfo",
		[]string{"hasNextPage", "hasPreviousPage", "startCursor", "endCursor"})

	return &PageInfoExec{ret}
}

func (instance *UserConnectionExec) Edges() *UserEdgeExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserEdge"},
		"edges",
		[]string{"cursor"})

	return &UserEdgeExec{ret}
}

func (instance *UserConnectionExec) Aggregate(ctx context.Context) (Aggregate, error) {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AggregateUser"},
		"aggregate",
		[]string{"count"})

	var v Aggregate
	_, err := ret.Exec(ctx, &v)
	return v, err
}

func (instance UserConnectionExec) Exec(ctx context.Context) (*UserConnection, error) {
	var v UserConnection
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserConnectionExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserConnectionExecArray struct {
	exec *prisma.Exec
}

func (instance UserConnectionExecArray) Exec(ctx context.Context) ([]UserConnection, error) {
	var v []UserConnection
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserConnection struct {
}

type UserEdgeExec struct {
	exec *prisma.Exec
}

func (instance *UserEdgeExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "email", "firstName", "lastName", "userName", "gender", "isAdmin", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

func (instance UserEdgeExec) Exec(ctx context.Context) (*UserEdge, error) {
	var v UserEdge
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserEdgeExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserEdgeExecArray struct {
	exec *prisma.Exec
}

func (instance UserEdgeExecArray) Exec(ctx context.Context) ([]UserEdge, error) {
	var v []UserEdge
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserEdge struct {
	Cursor string `json:"cursor"`
}

type AddressSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *AddressSubscriptionPayloadExec) Node() *AddressExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Address"},
		"node",
		[]string{"id", "addressName", "state", "city", "country"})

	return &AddressExec{ret}
}

func (instance *AddressSubscriptionPayloadExec) PreviousValues() *AddressPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "AddressPreviousValues"},
		"previousValues",
		[]string{"id", "addressName", "state", "city", "country"})

	return &AddressPreviousValuesExec{ret}
}

func (instance AddressSubscriptionPayloadExec) Exec(ctx context.Context) (*AddressSubscriptionPayload, error) {
	var v AddressSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AddressSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AddressSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance AddressSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]AddressSubscriptionPayload, error) {
	var v []AddressSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AddressSubscriptionPayload struct {
	UpdatedFields []string `json:"updatedFields,omitempty"`
}

type AddressPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance AddressPreviousValuesExec) Exec(ctx context.Context) (*AddressPreviousValues, error) {
	var v AddressPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance AddressPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type AddressPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance AddressPreviousValuesExecArray) Exec(ctx context.Context) ([]AddressPreviousValues, error) {
	var v []AddressPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type AddressPreviousValues struct {
	ID          string `json:"id"`
	AddressName string `json:"addressName"`
	State       string `json:"state"`
	City        string `json:"city"`
	Country     string `json:"country"`
}

type ImageSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *ImageSubscriptionPayloadExec) Node() *ImageExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "Image"},
		"node",
		[]string{"id", "name"})

	return &ImageExec{ret}
}

func (instance *ImageSubscriptionPayloadExec) PreviousValues() *ImagePreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "ImagePreviousValues"},
		"previousValues",
		[]string{"id", "name"})

	return &ImagePreviousValuesExec{ret}
}

func (instance ImageSubscriptionPayloadExec) Exec(ctx context.Context) (*ImageSubscriptionPayload, error) {
	var v ImageSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ImageSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ImageSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance ImageSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]ImageSubscriptionPayload, error) {
	var v []ImageSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ImageSubscriptionPayload struct {
	UpdatedFields []string `json:"updatedFields,omitempty"`
}

type ImagePreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance ImagePreviousValuesExec) Exec(ctx context.Context) (*ImagePreviousValues, error) {
	var v ImagePreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance ImagePreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type ImagePreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance ImagePreviousValuesExecArray) Exec(ctx context.Context) ([]ImagePreviousValues, error) {
	var v []ImagePreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type ImagePreviousValues struct {
	ID   string `json:"id"`
	Name string `json:"name"`
}

type UserSubscriptionPayloadExec struct {
	exec *prisma.Exec
}

func (instance *UserSubscriptionPayloadExec) Node() *UserExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "User"},
		"node",
		[]string{"id", "email", "firstName", "lastName", "userName", "gender", "isAdmin", "createdAt", "updatedAt"})

	return &UserExec{ret}
}

func (instance *UserSubscriptionPayloadExec) PreviousValues() *UserPreviousValuesExec {
	ret := instance.exec.Client.GetOne(
		instance.exec,
		nil,
		[2]string{"", "UserPreviousValues"},
		"previousValues",
		[]string{"id", "email", "firstName", "lastName", "userName", "gender", "isAdmin", "createdAt", "updatedAt"})

	return &UserPreviousValuesExec{ret}
}

func (instance UserSubscriptionPayloadExec) Exec(ctx context.Context) (*UserSubscriptionPayload, error) {
	var v UserSubscriptionPayload
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserSubscriptionPayloadExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserSubscriptionPayloadExecArray struct {
	exec *prisma.Exec
}

func (instance UserSubscriptionPayloadExecArray) Exec(ctx context.Context) ([]UserSubscriptionPayload, error) {
	var v []UserSubscriptionPayload
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserSubscriptionPayload struct {
	UpdatedFields []string `json:"updatedFields,omitempty"`
}

type UserPreviousValuesExec struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExec) Exec(ctx context.Context) (*UserPreviousValues, error) {
	var v UserPreviousValues
	ok, err := instance.exec.Exec(ctx, &v)
	if err != nil {
		return nil, err
	}
	if !ok {
		return nil, ErrNoResult
	}
	return &v, nil
}

func (instance UserPreviousValuesExec) Exists(ctx context.Context) (bool, error) {
	return instance.exec.Exists(ctx)
}

type UserPreviousValuesExecArray struct {
	exec *prisma.Exec
}

func (instance UserPreviousValuesExecArray) Exec(ctx context.Context) ([]UserPreviousValues, error) {
	var v []UserPreviousValues
	err := instance.exec.ExecArray(ctx, &v)
	return v, err
}

type UserPreviousValues struct {
	ID        string `json:"id"`
	Email     string `json:"email"`
	FirstName string `json:"firstName"`
	LastName  string `json:"lastName"`
	UserName  string `json:"userName"`
	Gender    string `json:"gender"`
	IsAdmin   bool   `json:"isAdmin"`
	CreatedAt string `json:"createdAt"`
	UpdatedAt string `json:"updatedAt"`
}
